<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Game Development | Martin Foot]]></title>
  <link href="http://mfoo.github.com/blog/categories/game-development/atom.xml" rel="self"/>
  <link href="http://mfoo.github.com/"/>
  <updated>2013-01-22T22:12:00+00:00</updated>
  <id>http://mfoo.github.com/</id>
  <author>
    <name><![CDATA[Martin Foot]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Choosing a maths library for cross-platform C++ game development]]></title>
    <link href="http://mfoo.github.com/blog/2012/01/23/choosing-a-maths-library-for-cross-platform-c-game-development/"/>
    <updated>2012-01-23T15:35:28+00:00</updated>
    <id>http://mfoo.github.com/blog/2012/01/23/choosing-a-maths-library-for-cross-platform-c-game-development</id>
    <content type="html"><![CDATA[<p>I have recently been looking for a C++ maths library for use in game development projects. There are plenty of posts on websites like <a href="http://gamedev.stackexchange.com/">gamedev.stackexchange.com</a> with suggestions for libraries but few quantitative comparisons between them. I decided to take three of the most popular libraries and run some tests of my own. Below I describe the three libraries I've compared with their advantages and disadvantages and then show the results of some performance tests. It's important for me to have cross-platform compatibility, so each library selected is header only and has been tested on Mac, Linux, and Android using the NDK. The code and results are also available <a href="https://github.com/mfoo/Math-Library-Test">on GitHub</a> for testing.</p>

<p>The libraries tested are:</p>

<ul>
<li><p><a href="http://eigen.tuxfamily.org/">Eigen</a></p></li>
<li><p><a href="http://glm.g-truc.net/">GLM</a></p></li>
<li><p><a href="http://cmldev.net/">CML</a></p></li>
</ul>


<p>These choices are largely influenced by reading their websites and posts at the <a href="http://gamedev.stackexchange.com/">Game Development StackExchange</a> site:</p>

<ul>
<li><p><a href="http://gamedev.stackexchange.com/questions/9924/best-c-math-library-for-game-engine">Best C Math Library for Game Engine?</a></p></li>
<li><p><a href="http://stackoverflow.com/questions/5935075/high-performance-math-library-for-vector-and-matrix-calculations">High Performance Math Library for Vector And Matrix Calculations</a></p></li>
<li><p><a href="http://gamedev.stackexchange.com/questions/8234/complete-math-library-for-use-in-opengl-es-2-0-game">Complete Math Library for use in OpenGL ES 2.0 Game?</a></p></li>
</ul>


<h1>Requirements</h1>

<p>I have several requirements for a math library, and when rating them (in no particular order) the <a href="http://gamedev.stackexchange.com/questions/21711/what-should-be-taken-into-consideration-when-choosing-a-math-library-for-games">following things are important</a>:</p>

<ul>
<li><p>License</p></li>
<li><p>Portability</p></li>
<li><p>Quality and quantity of the documentation</p></li>
<li><p>Completeness (or how much can the library do without me having to write my own functions). For game development this includes:</p>

<ul>
<li><p>Matrix operations</p></li>
<li><p>Vector operations</p></li>
<li><p>Complex number support</p></li>
<li><p>Quaternion operations</p></li>
</ul>
</li>
<li><p>Extensibility and community contributions (linked directly to the above).</p></li>
<li><p>Ease of use (are the concepts simple to understand?)</p></li>
<li><p>Performance (are there SIMD optimisations?)</p></li>
</ul>


<h1>Libraries Overview</h1>

<h2>Configurable Math Library (CML)</h2>

<p>This is a free library designed for games, graphics, and computational geometry applications. Listed <a href="http://cmldev.net/?page_id=8">features</a> include:</p>

<ul>
<li><p>Vector, matrix, and quarternion classes</p></li>
<li><p>Templated headers so can be used for arbitrary types</p></li>
<li><p>Arbitrary sized vectors and matrices (fixed or dynamically resizable)</p></li>
<li><p>Conversions between polar, cylindrical, spherical, and Cartesian coordinates</p></li>
<li><p>A large library of functions for the construction and manipulation of transforms in 2D and 3D</p></li>
</ul>


<p>CML's <a href="http://cmldev.net/?page_id=594">design notes</a> state that it is meant to be cross-platform and portable and therefore doesn't contain any platform specific optimisations, but it is possible to include them in the future if there is specific interest.</p>

<p>There's only one header file to include, <code>cml/cml.h</code>.</p>

<p>CML contains quite a nice way of creating an abstraction layer between existing math library objects and CML objects, allowing the use of other math library data types in CML library functions. See <a href="http://cmldev.net/?p=424">here</a>.</p>

<p>CML only has a few <a href="http://cmldev.net/?p=402">examples</a>. Hasn't been updated in a while. Contains useful functions for working with OpenGL or DirectX though, including replacements for things like gluLookAt().</p>

<p>CML is released under the <a href="http://cmldev.net/?p=430">Boost Software License</a>. This means that you're allowed to use and profit from the library as long as when distributing CML or any modifications you have made to CML, you keep the Boost Software License text in each file.</p>

<h2>Eigen</h2>

<p>This library has by far the most detailed and descriptive tutorial section with many code samples. It is also worth noting that it seems to be the most frequently updated and the most up-to-date (at the time of writing the most recent release, 3.0.4, was 3.5 weeks ago).</p>

<p>Like GLM, it is very easy to pass the class objects directly to OpenGL, although in Eigen this is performed by an <a href="http://eigen.tuxfamily.org/dox-devel/unsupported/group__OpenGLSUpport__Module.html">unsupported OpenGL module</a> which provides a few functions such as glTranslate and glRotate.</p>

<pre><code>// You need to add path_to_eigen/unsupported to your include path.
#include &lt;Eigen/OpenGLSupport&gt;
// ...
Vector3f x, y;
Matrix3f rot;
glVertex(y + x * rot);

Quaternion q;
glRotate(q);
</code></pre>

<p>Provides a large number of array, matrix, and vector types with <a href="http://eigen.tuxfamily.org/dox/QuickRefPage.html#QuickRef_Types">many operators</a>.</p>

<p>Eigen is licensed under the LGPL which is quite restrictive and usually would exclude a library based on my requirements. However, Eigen has a large <a href="http://eigen.tuxfamily.org/index.php?title=Licensing_FAQ">Licensing FAQ</a> which tries to answer any licensing questions people might have. Their main point is that as Eigen is a header only library, it does not count as a "Combined Work" under the LGPL it can be therefore used entirely under Section 3. This states that to use Eigen you must:</p>

<ul>
<li><p>Give prominent notice with each copy of the object code that the Library is used in it and that the Library and its use are covered by this License. The Eigen FAQ states that 'the bottom of a README file or of a website would be prominent enough for us'.</p></li>
<li><p>Accompany the object code with a copy of the GNU GPL and this license document.</p></li>
</ul>


<p>This assumes that you're using Eigen unmodified. If you are planning to make changes to Eigen and release it, then you must also make the modifications available under the LGPL.</p>

<h2>OpenGL Math Library (GLM)</h2>

<p>GLM's main design to be very familiar to those who know GLSL as it uses classes and functions that use the GLSL naming conventions. It also seems to provide all of the functionality that I might need in the future.</p>

<p>Includes several code samples, more than CML. Many more located in the manual.</p>

<p>Includes features such as:</p>

<ul>
<li><p>Math for splines</p></li>
<li><p>Math for colour spaces</p></li>
<li><p>Random numbers</p></li>
<li><p>Simplex noise generation</p></li>
<li><p>Conversion of Euler angles</p></li>
</ul>


<p>There's only one header file to include, <code>glm/glm.hpp</code>. <code>glm/ext.hpp</code> can be included to add extended features (non GLSL features).</p>

<p>The design choice to follow GLSL conventions allows the library to be intuitive and easy to use, especially given that data alignment is compatible with gl functions. E.g:</p>

<pre><code>glm::vec4 v(0);
glm::mat4 m(0);
glVertex3fv(glm::value_ptr(v));
glLoadMatrixfv(glm::value_ptr(m));
</code></pre>

<p>The manual pdf file link is broken but a slightly out of date version can be found <a href="https://bitbucket.org/alfonse/gltut/src/6332c7f79903/glm-0.9.0.0/doc/glm-manual.pdf">here</a>. I've sent the maintainer an email and hopefully this will be fixed shortly.</p>

<p>GLM is licensed under the <a href="http://en.wikipedia.org/wiki/MIT_License">MIT License</a> (Expat License) which is very permissive and means GLM is a good candidate for any project requiring a math library.</p>

<p>To run the tests on Android you will need the <a href="http://developer.android.com/sdk/ndk/index.html">Android NDK</a> and <a href="http://code.google.com/p/android-cmake/">android-cmake</a>. For Ant you will need to specify your Android SDK location in <code>android/local.properties</code>. I have included prebuilt libraries for armeabi and armeabi-v7a so if you don't want to compile them yourself you can skip straight to the ant commants.</p>

<h1>Results</h1>

<p>So far I've tested matrix addition and multiplication. <code>src/Main.cpp</code> contains code that will generate two lists of 1 million 4x4 float matrices for each library, populate them with random float values, and then add each one from the first column to the second. It will then do the same for multiplication. It will repeat this step 10 times and print out how long it took for each library.</p>

<p>Results for each library vary greatly with architecture and optimisation level. I have tested standard GCC build on Mac OS X Lion as well as an SSE enabled build, and armeabi, armeabi-v7a and armeabi-v7a with NEON instructions for Android.</p>

<p>Note that all tests use the <code>-O2</code> GCC optimisation flag except the non-SSE laptop build which uses <code>-O0</code>.</p>

<p>Results for addition and multiplication are shown below. Note that the laptop I'm using is an i7 2.2ghz early 2011 MacBook Pro and the Android device is a Stock HTC Desire (2.2) with a 1 GHz Qualcomm QSD8250. All times are in milliseconds.</p>

<pre><code>                        laptop  laptop (SSE)  armeabi  armeabi-v7a  armeabi-v7a with neon
Eigen additions         8065    30            9944     2181         2145
Eigen multiplications   22404   86            59460    5143         5113
GLM additions           2375    76            10256    1506         1407
GLM multiplications     7337    400           59008    2189         3108
CML additions           12336   96            9587     2885         2996
CML multiplications     21603   551           58399    5306         5280
</code></pre>

<p>The first column for the laptop doesn't have any compile-time optimisations and is included purely for interest. From the other results, Eigen seems to be the fastest for these operations, but GLM is the fastest on the HTC Desire with both ABIs. I am not sure why the NEON times are not much faster (and in some cases, slower) but will update this post when I learn more.</p>

<p>Despite GLM being faster on the mobile devices, I am more inclined to use Eigen due to its speed on the tested Intel CPU and its much better documentation and more active community.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes on Android Graphics and Animations]]></title>
    <link href="http://mfoo.github.com/blog/2011/12/04/notes-on-android-graphics-and-animations/"/>
    <updated>2011-12-04T13:34:33+00:00</updated>
    <id>http://mfoo.github.com/blog/2011/12/04/notes-on-android-graphics-and-animations</id>
    <content type="html"><![CDATA[<p>This post contains my notes on the Youtube Video "<a href="http://www.youtube.com/watch?v=duefsFTJXzc">Learn about Android Graphics &amp; Animations from Google's Android UI Toolkit Team</a>" which shows a talk given by Romain Guy and Chet Haase from Google at the San Francisco Android User Group, Nov 20th 2010. Note that at the time of writing the video is already quite old, but much of it is still relevant and it's well worth a watch for anybody interested in working with graphics in Android. This post is partly for me to remember and refer back to, but hopefully others will find it useful. The video is embedded below and notes can be found after the break:</p>

<p>http://www.youtube.com/watch?v=duefsFTJXzc</p>

<p>So, summary of the video:</p>

<ul>
<li><p><strong>Surface</strong> is the name for the buffer that objects are rendered into, whether on-screen or off-screen.</p></li>
<li><p>05:23: <strong>PixelFlinger</strong> is the equivalent of a JIT for the software implementation of OpenGL that's used in the Android emulator. This is pretty interesting, it generates assembly code at runtime based on what render operations you're performing.</p></li>
<li><p>06:00: <strong>View</strong>s are the basic UI components, for instance each of the UI widgets inherits from View. <strong>ViewGroup</strong>s contain zero or more views and provide the base class for layouts and view containers, allowing you to modify the contents of the container and set properties for how the view children are displayed. <strong>SurfaceView</strong>s are special Views that allow you to place Surfaces at certain points in the screen. Android also provides classes such as the <a href="http://developer.android.com/reference/android/opengl/GLSurfaceView.html">GLSurfaceView</a> which enables OpenGL to render into the Surface and the <a href="http://developer.android.com/reference/android/widget/VideoView.html">VideoView</a> which allows videos to be rendered as well as providing video playback controls.</p></li>
<li><p>06:40 Applications can render via a Canvas (which uses Google's Skia library) or via RenderScript (which currently makes OpenGL calls) or via OpenGL directly. Each rendering method eventually renders onto the specified kind of Surface.</p></li>
<li><p>07:25 Android supports OpenGL ES 1.x and 2.0, and you can use either of these on a device that supports it, early devices and devices running versions before Android 2.2 will not support OpenGL ES 2.0 - see <a href="https://secure.wikimedia.org/wikipedia/en/wiki/OpenGL_ES#Usage">here</a> for a list of devices that support each version. If you are using the Android Emulator then you will be using PixelFlinger which only supports OpenGL ES 1.x.</p></li>
<li><p>08:15 Whenever a frame is drawn, <strong>SurfaceFlinger</strong> produces a composite from each visible View and renders them to a Surface (frame buffer) via either OpenGL or PixelFlinger depending on whether the software GL implementation is being used or not. Older devices used a 2D blitter called MDP.</p></li>
<li><p> 09:20 Android won't redraw a View unless it's both visible and flagged ('dirty') by calling it's <a href="http://developer.android.com/reference/android/view/View.html#invalidate(">invalidate()</a>) method. This invalidate call will propagate up to any ViewGroups in the view hierarchy to the <strong>ViewRoot</strong> which will lock the Surface of the window and then call draw() on all of it's children. When that's done the ViewRoot will unlock the canvas and swap the buffers. All windows on Android are double buffered.</p></li>
<li><p>15:00 Demo from Chet about how to add animations and effects on Views. Animations can be used for subtle indications - for instance to indicate whether an image is selected or not it's nice to have an animation/transitioning effect rather than an abrupt change in the UI.</p></li>
<li><p>16:56 Unlike Java2D, Android's Canvas is virtually stateless and uses <strong>Paint</strong>s to specify font size, text colour, colour, opacity, filtering, dithering, anti-aliasing etc. These objects contain a lot of state information and are therefore fairly heavy-weight. Making a new Paint object every frame is not a good idea as you will soon saturate the heap and cause Garbage Collection.</p></li>
<li><p>18:15 <strong>Shaders</strong> specify how to draw horizontal or vertical spans of colours (for example different kinds of gradients), i.e. how to fill a shape. These are not the same as GLSL shaders. <strong>ComposeShader</strong> will blend two shaders together and fill the shape with that. <strong>ColorFilter</strong>s perform operations on each pixel they are applied to.</p></li>
<li><p>21:00 <strong>XferModes</strong> or blending modes such as Porter-Duff (scientists who defined 12 equations that explain how transparency affects colours) and Darken, Lighten, Multiply and Screen allow modifying the colours of a Canvas. For instance, a BitmapShader and a LinearGradient can be combined with a ComposeShader to draw a bitmap that fades out.</p></li>
<li><p>23:17 Demo from Chet showing some example code for using creating new Bitmaps that arise from applying Shaders on Bitmaps. Shaders are created and then the Paint object is told to use that shader. You can then simply draw a rectangle to the screen using the specified Paint and it will perform the shader operations you specified on that rectangle.</p></li>
<li><p>25:00<strong> Bitmap</strong>s are either mutable or immutable and have the concept of resolution. Android allows you to specify different assets for different screen resolutions in the same package, and if you place a drawable in the medium resolution folder and are running on a phone which reports itself as high resolution, Android will use that information to scale the Bitmap automatically when it is displayed. Bitmaps can be large objects so they can be recycled without having to wait for the garbage collector. Supported Bitmap formats are <strong>ALPHA_8 </strong>(for alpha masks), <strong>ARGB_4444</strong> (this isn't recommended, uses 4 bits for each component and therefore doesn't look very good), <strong>ARGB_8888</strong> (recommended, 32 bit images, allows for transparency), and <strong>RGB_565</strong> (doesn't contain alpha channel, limited precision for colours, faster to draw, uses dithering). JPEG images do not contain transparency and pre-Gingerbread were loaded automatically with RGB_565. <strong>This meant that jpg images automatically lost some quality pre-gingerbread</strong>. Post Gingerbread all images are loaded by default as ARGB_8888 (and application memory usage limits are increased to compensate). When loading a Bitmap, make sure to specify the format that you want, otherwise it will be loaded as it's default and every time the Bitmap is drawn it will need to be converted. For instance, pre-Gingerbread the default bit depth for a Surface is 16 bits, so a 32 bit image will need to be converted before rendering which can be slow. You can control quality of this rendering by enabling/disabling dithering on the Paint object and the Drawable object that the Bitmap's being used by. Blending should be avoided with the alpha channel. If Android detects an image is completely opaque it can perform a faster rendering pass.</p></li>
<li><p>30:00 Demo by Romain showing the effects of precision loss when rendering 32 bit images onto a 16 bit window (introduces artefacts, gradients look banded). Enabling dithering removes the banding somewhat and improves the gradient. Using a 32 bit window ARGB_8888 with no dithering looks fine while ARGB_4444 still looks bad (and hence isn't recommended anywhere).</p></li>
<li><p>33:10 Slide showing performance comparisons for different bitmap image types on different surfaces. Drawing an ARGB_8888 surface is three times faster on a 32 bit surface than a 16 bit surface. ARGB_4444 is slightly faster than ARGB_8888 on a 16 bit surface. RGB_565 is 12 times faster than ARGB_8888 and 8 times faster than ARGB_4444 when rendering to a 16 bit surface (as it's essentially a memcpy on a 16 bit surface) but three times slower than ARGB_8888 and almost twice as slow as ARGB_4444 on a 32 bit surface.</p></li>
<li><p>35:50 Demo of two different ways to copy a View into a Bitmap.</p></li>
<li><p>37:30 Chet takes over, talks about Animations. Animations enable better user experiences and can help users use the application, especially on smaller screens. The current (as of the talk) SDK has an animation superclass which controls timing, repetition, interpolation and ending states. Nonlinear interpolation on animations such as view sliding is important as it looks much better than linear motion.</p></li>
<li><p>40:30 Android allows for Transforming operations (translation, rotation, scale), Fading, Sequences (allowing you to choreograph multiple animations), Cross-fading, and Layout animations (ViewGroups can animate the display of their children via animations rather than displaying them instantly).</p></li>
<li><p>41:40 Animations are about making things <em>look animated</em> rather than actually <em>being</em> animated. <strong>This means that moving views via animations doesn't actually move the view. </strong>If you move a button, you need to move the actual object afterwards to ensure that it will handle input events for the correct position. This is because the ViewGroup, when rendering it's children, detects first if an animation is playing on the child before rendering it. If it is, it renders the current state of the animation rather then the View's original settings.</p></li>
<li><p>43:16 Fading is done by interpolating alpha values, which again is not the transparency of the View, but the transparency that the View will be drawn with (see previous point).</p></li>
<li><p>45:30 Layout animations are based on staggering some template animation for each child of the view.</p></li>
<li><p>46:50 With animations you can setDrawingCacheEnabled(True) to allow the animation to represent itself as a Bitmap which means that the animated object doesn't need to be re-rendered each frame. This is a large performance increase and is used in Android everywhere transparently. <strong>As soon as a finger touches a view (for example a ScrollView) each of the Views in the ViewGroup are transformed into Bitmaps via setDrawingCacheEnabled which allows them to be scrolled quickly without having to re-render them.</strong> When a Bitmap is off the screen it can be recycled and used by another View.</p></li>
<li><p>You can follow Romain Guy at @romainguy and curious-creature.org.</p></li>
<li><p>You can follow Chet Haase at @chethaase and graphics-geek.blogspot.com.</p></li>
</ul>


<p>Slides of this talk can be found at <a href="http://marakana.com/f/212">http://marakana.com/f/212</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using compressed assets in LibRocket via PhysicsFS]]></title>
    <link href="http://mfoo.github.com/blog/2011/09/04/using-compressed-assets-in-librocket-via-physicsfs/"/>
    <updated>2011-09-04T10:37:45+01:00</updated>
    <id>http://mfoo.github.com/blog/2011/09/04/using-compressed-assets-in-librocket-via-physicsfs</id>
    <content type="html"><![CDATA[<p><a href="librocket.com">LibRocket</a> is a system that allows you to define user interface elements for OpenGL/DirectX applications in HTML and CSS. As well as being easy to get started with and powerful, this is really useful as it means you can load UI elements from files that can be edited without needing to recompile the application. It provides several interface classes that you can customise based on your current platform to allow it to play nice with any other libraries you may be using.</p>

<p>I've been storing compressed project assets using <a href="icculus.org/physfs/">PhysicsFS</a>, which allows for direct read/write access to compressed files such as zip files. After a little fiddling, I produced the class below that allows LibRocket to read it's assets via PhysicsFS.</p>

<p>RocketFileSystemInterface.h:</p>

<p>[code lang="cpp"]</p>

<h1>ifndef <em>ROCKETFILESYSTEMINTERFACE_H</em></h1>

<h1>define <em>ROCKETFILESYSTEMINTERFACE_H</em></h1>

<h1>include &lt;Rocket/Core/FileInterface.h></h1>

<p>/<em>*
 * A FileInterface for libRocket (http://librocket.com/) that enables the
 * reading of files via PhysicsFS (http://icculus.org/physfs/) directly from a
 * compressed archive.
 *
 * Note: The PhysicsFS system must be initialised before this class is used via
 * PHYSFS_init() and any archives must be made searchable via
 * PHYSFS_addToSearchPath().
 *
 * Author: Martin Foot
 * Date: 4th September 2011
 </em>/
namespace Delta {
class RocketFileSystemInterface : public Rocket::Core::FileInterface {</p>

<pre><code>public:
    RocketFileSystemInterface();
    ~RocketFileSystemInterface();

    /**
     * Get a read only filehandle to the specified file.
     * @param path  The filename in the compressed archive.
     * @return A Rocket filehandle to the opened file. This can be NULL on
     * failure.
     */
    Rocket::Core::FileHandle Open(const Rocket::Core::String&amp; path);

    /**
     * Close a previously opened file.
     * @param file  The Rocket filehandle to close.
     */
    void Close(Rocket::Core::FileHandle file);

    /**
     * Attempt to read the specified number of bytes into the provided
     * buffer. If the specified number of bytes is greater than the size of
     * the file, only  bytes will be copied.
     * @param buffer    The buffer to read into.
     * @param size  The number of bytes to read.
     * @param file  The Rocket filehandle.
     * @return  The actual number of bytes that was read into the buffer.
     */
    size_t Read(void* buffer, size_t size, Rocket::Core::FileHandle file);

    /**
     * Seek to a point in the previously opened file.
     * @param file  The Rocket filehandle.
     * @param offset    The number of bytes to seek to relative to the
     * supplied origin.
     * @param   One of SEEK_SET (seek relative to the beginning of the file),
     * SEEK_CUR (seek relative to the current position in the file) or
     * SEEK_END (relative to the end of the file).
     * @return  Whether seeking was a success or not.
     */
    bool Seek(Rocket::Core::FileHandle file, long offset, int origin);

    /**
     * Get the length of the file.
     * @param file  The Rocket filehandle.
     * @return  The size in bytes of the file.
     */
    size_t Length(Rocket::Core::FileHandle file);

    /**
     * Get the current read pointer offset.
     * @param file  The Rocket filehandle.
     * @return  The current offset. Returns 0 on failure.
     */
    size_t Tell(Rocket::Core::FileHandle file);
};
</code></pre>

<p>}</p>

<h1>endif // <em>ROCKETFILESYSTEMINTERFACE_H</em></h1>

<p>[/code]</p>

<p>RocketFileSystemInterface.cpp:</p>

<p>[sourcecode language="cpp"]</p>

<h1>include "RocketFileSystemInterface.h"</h1>

<h1>include &lt;Rocket/Core.h></h1>

<h1>include &lt;Rocket/Core/Types.h></h1>

<h1>include &lt;physfs.h></h1>

<h1>include <cstdio></h1>

<h1>include <string></h1>

<h1>include "FileSystemInterface.h"</h1>

<p>using Delta::FileSystemInterface;</p>

<p>namespace Delta {</p>

<p>RocketFileSystemInterface::RocketFileSystemInterface() : FileInterface() {};</p>

<p>RocketFileSystemInterface::~RocketFileSystemInterface() {};</p>

<p>Rocket::Core::FileHandle RocketFileSystemInterface::Open(const Rocket::Core::String&amp; path) {</p>

<pre><code>if (!PHYSFS_exists(path.CString())) {
    return NULL;
}

PHYSFS_file* file = PHYSFS_openRead(path.CString());
return static_cast&lt;PHYSFS_file*&gt;((uintptr_t)file);
</code></pre>

<p>}</p>

<p>void RocketFileSystemInterface::Close(Rocket::Core::FileHandle file) {</p>

<pre><code>PHYSFS_close(static_cast&lt;PHYSFS_file*&gt;((void *)file));
</code></pre>

<p>}</p>

<p>size_t RocketFileSystemInterface::Read(void* buffer, size_t size, Rocket::Core::FileHandle file) {</p>

<pre><code>PHYSFS_file* ptr = static_cast&lt;PHYSFS_file*&gt;((void *) file);

// Don't read past the end of the file or PhysicsFS will return an error.
size_t length = PHYSFS_fileLength(ptr);
if(size &gt; length) {
    size = length;
}

size_t read = PHYSFS_read(ptr, buffer, size, 1);

return read * size;
</code></pre>

<p>}</p>

<p>bool RocketFileSystemInterface::Seek(Rocket::Core::FileHandle file, long offset, int origin) {</p>

<pre><code>PHYSFS_file* ptr = static_cast&lt;PHYSFS_file*&gt;((void *)file);

int response = 0;

switch(origin) {
    case SEEK_SET:
        // Seek from the beginning of the file.
        response = PHYSFS_seek(ptr, offset);
        break;
    case SEEK_CUR:
        // Offset from the current position.
        response = PHYSFS_seek(ptr, offset + PHYSFS_tell(ptr));
        break;
    case SEEK_END:
        response = PHYSFS_seek(ptr, PHYSFS_fileLength(ptr));
        break;
}

if(response == 0)
    return false;

return true;
</code></pre>

<p>}</p>

<p>size_t RocketFileSystemInterface::Tell(Rocket::Core::FileHandle file) {</p>

<pre><code>PHYSFS_file* ptr = static_cast&lt;PHYSFS_file*&gt;((void *)file);
size_t offset = PHYSFS_tell(ptr);
return offset;
</code></pre>

<p>}</p>

<p>size_t RocketFileSystemInterface::Length(Rocket::Core::FileHandle file) {</p>

<pre><code>PHYSFS_file* ptr = static_cast&lt;PHYSFS_file*&gt;((void *)file);
return PHYSFS_fileLength(ptr);
</code></pre>

<p>}</p>

<p>}
[/sourcecode]</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Game Development RSS Feeds]]></title>
    <link href="http://mfoo.github.com/blog/2010/09/23/game-development-rss-feeds/"/>
    <updated>2010-09-23T02:00:14+01:00</updated>
    <id>http://mfoo.github.com/blog/2010/09/23/game-development-rss-feeds</id>
    <content type="html"><![CDATA[<p>In my attempt to keep my ear to the floor with the happenings in the game industry I have collected a bunch of interesting blogs into a Google Reader shared collection. These feeds are gathered from several places including manual searching and several really <a href="http://gamedev.stackexchange.com/questions/3223/game-development-blogs">useful posts</a> on the subject. Including game art, design,  theory, planning/management/publishing, and coding, there's a lot of brilliant information here!</p>

<p>So, if anybody is interested:</p>

<p><a href="http://www.google.com/reader/bundle/user/04706940339159059157/bundle/Game%20Development">Link</a></p>
]]></content>
  </entry>
  
</feed>
